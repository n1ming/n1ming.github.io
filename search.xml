<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>同花顺js逆向cookie</title>
      <link href="/2025/03/29/%E5%90%8C%E8%8A%B1%E9%A1%BAjs%E9%80%86%E5%90%91cookie/"/>
      <url>/2025/03/29/%E5%90%8C%E8%8A%B1%E9%A1%BAjs%E9%80%86%E5%90%91cookie/</url>
      
        <content type="html"><![CDATA[<h1 id="同花顺js逆向cookie"><a href="#同花顺js逆向cookie" class="headerlink" title="同花顺js逆向cookie"></a>同花顺js逆向cookie</h1><p>案例网址：<a href="https://q.10jqka.com.cn/">https://q.10jqka.com.cn/</a></p><p>逆向目标：</p><p><img src="/static/BJD7brLixoL4p5xohFccUDEGnzW.png"></p><p>cookie 中的参数 v，具有时效性，刷新一下就会发生变化：</p><p><img src="/static/EI5vbERa9owbI8xgePWcLRjnnBh.png"></p><p>所以不好做长期的爬虫，需要进行逆向解密。</p><p>进行逆向的第一步是要找到其生成逻辑的地方。可以尝试全局搜索 cookie，一个一个找。</p><p><img src="/static/R3ECbPvHRoyxMBxNWB5c1fUIngb.png"></p><p>可以找到最后一个是其生成逻辑的文件：</p><p><img src="/static/NQo7bpByboGsCvxKx0GciYkDnGb.png"></p><p>这是一个立即执行函数。上面有个全局变量，从变量名可知是时间，所以 cookie 的变化可能跟这个有关系。</p><p>这是一种方法，需要一个一个排查，有点耗时耗力。</p><p>最好的方法就是 hook 注入。可以用油猴插件，也可以用浏览器自带的脚本片段。</p><p><img src="/static/SRWHbKt5noGqMwxjYTjcryYvnUg.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 自执行函数</span><br><span class="line">(function()&#123;</span><br><span class="line">    var cookie_cache = document.cookie;</span><br><span class="line">    Object.defineProperty(document, &#x27;cookie&#x27;,&#123;</span><br><span class="line">        get:function()&#123;  // 访问cookie触发</span><br><span class="line">            console.log(&#x27;Get cookie&#x27;);</span><br><span class="line">            return cookie_cache;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:function(val)&#123;  // 设置cookie触发</span><br><span class="line">            console.log(&#x27;Set cookie&#x27;,val);</span><br><span class="line">            debugger</span><br><span class="line">            return cookie_cache;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>cookie 是 document 对象的一个属性。所以这个 hook 脚本意思就是定义一个方法用来监听 document 的 set-cookie 方法，如果监听成功，则打上断点。</p><p>运行一下，然后点击其它页，发生断点。</p><p><img src="/static/EuEYbd5xbo2hqQxiLYoc0YafnUd.png"></p><p>然后查看旁边的作用域和调用堆栈。作用域就是当前的结果，而作用堆栈就是出现这个结果所经历的路程。</p><p>调到 o，发现 cookie 传给了变量 t：</p><p><img src="/static/W1hlbJoAWovTIRxdha6ce0wOnkd.png"></p><p>这里只是表面上的函数，继续往下查看。</p><p><img src="/static/KelibS01So9WtvxPK67cuSbGn6d.png"></p><p>发现 cookie 传给了 n，而 n&#x3D;rt.update()</p><p>在控制台里运行一下这个方法。</p><p><img src="/static/ZG46bgguAocne6xSOXDcrP55nvd.png"></p><p>发现就是生成 cookie 的方法。查看这个方法：</p><p><img src="/static/UPEsbkpGaoE5KDxmnWzcIEunnJg.png"></p><p>跳转到对应的页面：</p><p><img src="/static/BlMhbWX4topPK8x3nQdcg3PQnAd.png"></p><p>发现是个 D 函数，里面返回一个 O 函数。</p><p>网上找找，发现 O 函数就在上面。</p><p><img src="/static/AquubrJvGokMFYxU0uZclwEnnIb.png"></p><p>ok，再看间距发现这不是一个单独的函数，而是一个方法。跑到上面，发现是一个立即执行函数。</p><p><img src="/static/PuNrbIIQwoesfVxAAf9cYISxnEg.png"></p><p>那么也就是说 cookie 的具体生成逻辑就在这个立即执行函数里。将其整体复制到编辑器中进行下一步操作。</p><p><img src="/static/CSDdbN1fmo4eqxx7aUrcNMIgnCh.png"></p><p>在编辑器中运行这段代码肯定会报错。原因就是 nodejs 和浏览器相比缺少 dom 和 bom 环境。</p><p>什么是 dom 和 bom？</p><p>dom 就是 document 对象模型，而 bom 就是 browser 对象模型也就是 window 对象。</p><p>两者最本质的区别就在这里，所以要想运行成功必须要补上缺失的环境。</p><p><img src="/static/FQCPbabZYoEIHMxQOWdc5eYqnHC.png"></p><p>补上 document 对象，并且尝试打印他的 cookie 属性。记住一定要保存，然后运行，不出意外报错：</p><p><img src="/static/Je89b8ka2o2TRNxSTROcOv2InSd.png"></p><p>window 对象为定义，那么继续补 window 对象：</p><p><img src="/static/JvDhb8sgZopCtlxXFn8ceDcmnYb.png"></p><p>保存并运行，出现另一个错误：</p><p><img src="/static/Gps4bAzR4orqr1xwr4Acxu46njg.png"></p><p>r[51].getElementsByTagName 这个函数并不知道是什么。属于那个对象。</p><p>这里就需要环境代理了。正所谓缺啥补啥。</p><p>环境代理：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 环境代理</span><br><span class="line">function getEnvs(proxyObjs) &#123;</span><br><span class="line">    for (let i = 0; i &lt; proxyObjs.length; i++) &#123;</span><br><span class="line">        const handler = `&#123;</span><br><span class="line">      get: function(target, property, receiver) &#123;</span><br><span class="line">        console.log(&quot;方法:&quot;, &quot;get  &quot;, &quot;对象:&quot;, &quot;$&#123;proxyObjs[i]&#125;&quot;, &quot;  属性:&quot;, property, &quot;  属性类型：&quot;, typeof property, &quot;, 属性值：&quot;, target[property], &quot;, 属性值类型：&quot;, typeof target[property]);</span><br><span class="line">        return target[property];</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function(target, property, value, receiver) &#123;</span><br><span class="line">        console.log(&quot;方法:&quot;, &quot;set  &quot;, &quot;对象:&quot;, &quot;$&#123;proxyObjs[i]&#125;&quot;, &quot;  属性:&quot;, property, &quot;  属性类型：&quot;, typeof property, &quot;, 属性值：&quot;, value, &quot;, 属性值类型：&quot;, typeof target[property]);</span><br><span class="line">        return Reflect.set(...arguments);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;`;</span><br><span class="line">        eval(`try &#123;</span><br><span class="line">            $&#123;proxyObjs[i]&#125;;</span><br><span class="line">            $&#123;proxyObjs[i]&#125; = new Proxy($&#123;proxyObjs[i]&#125;, $&#123;handler&#125;);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            $&#123;proxyObjs[i]&#125; = &#123;&#125;;</span><br><span class="line">            $&#123;proxyObjs[i]&#125; = new Proxy($&#123;proxyObjs[i]&#125;, $&#123;handler&#125;);</span><br><span class="line">        &#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">proxyObjs = [&#x27;window&#x27;, &#x27;document&#x27;, &#x27;location&#x27;, &#x27;navigator&#x27;, &#x27;history&#x27;, &#x27;screen&#x27;]</span><br><span class="line">// ....</span><br><span class="line">getEnvs(proxyObjs);</span><br></pre></td></tr></table></figure><p>具体代码意思就是监听方法的对象类型。能监听的对象可以设置。</p><p>目前设置有：[‘window’, ‘document’, ‘location’, ‘navigator’, ‘history’, ‘screen’]</p><p><img src="/static/UFeTbyhcyosRQox7XwMcTP69nOh.png"></p><p>保存再次运行：</p><p><img src="/static/MfV6bj6mgoSODwxzWOWc9pLmnzT.png"></p><p>这样就知道 getElementsByTagName 这方法是哪个对象里的了。</p><p>那么缺啥补啥，补在 document 对象里。</p><p>但是还有个未知，就是这个方法有没有参数，如果有那是什么。</p><p>所以在补这个方法的时候可以让其自己输出是什么方法。</p><p><img src="/static/SIv2b7iezozAqWxbqGPc9pFCncb.png"></p><p>运行：</p><p><img src="/static/KfM2bt8xeo9cSdxOmxVcR0PnnI6.png"></p><p>传参是 head，那么返回的是什么呢。</p><p>这个方法所有的条件知道了，就可以在浏览器的控制台里&#x3D;查看返回的是什么。</p><p><img src="/static/PuSabVgXxofqbvxc8Udc4unOnjd.png"></p><p>返回的是一个对象。那么也照样返回对象，返回个空对象看看有没有报错。</p><p><img src="/static/LC8Vb83AtoeTLix51t6cokmbnER.png"></p><p>这回发现是另一个错误，从错误和环境代理的输出可以看出不是空对象导致的。</p><p>同样的将 createElement 放入 document 对象里，并补上方法。</p><p><img src="/static/UXhMbiqY4o7lMMxguKbcavVfnKh.png"></p><p>参数 div，同样的返回到浏览器的控制台查看</p><p><img src="/static/FASpbsGcEoTiybxUZw3ctJBEnUd.png"></p><p>那么添上。并运行。</p><p><img src="/static/A2UGby9POowYV5xr95Kc97G3nad.png"></p><p>还是同样的报错，说明还是有问题。</p><p>看看具体的问题：</p><p><img src="/static/LZyLbXOSroN06Xx3QkHcI9MJnDf.png"></p><p>去浏览器进行局部搜索看看，这里面到底是什么问题。</p><p><img src="/static/DBnRb1D6NodTBixNyGPcOfGNnKl.png"></p><p>然后打上断点，看看：</p><p><img src="/static/SbJgbPfSpohWW0xXrWVcasC5n6c.png"></p><p>在控制台里尝试看看这一行代码是什么意思</p><p>t + X in s[66].createElement(s[171])</p><p>t + X 是 onwheel，意思是 onwheel 在不在 s[66].createElement(s[171]) 里面，如果不在则执行 s[172]in c[66] ? u[173] : v + K + f + Q   这是三目运算符。</p><p>也就是说 createElement 这个方法返回的东西或许不是单单的字符串而是一个属性。那么在控制台里查看这个方法返回的所有属性，用 dir 函数。</p><p><img src="/static/CrEeb1lxEo4ohCx07ZtcFEPKnpg.png"></p><p>果然是属性，那么在属性里找 onwheel，因为这一行代码主要是检测 onwheel。</p><p><img src="/static/YwXbborspowWXvxfCUycwLevnUc.png"></p><p>onwheel：null，那么就填进去。</p><p><img src="/static/TpMobqAl2oNhaaxPSVfc0hnYnOb.png"></p><p>在运行：</p><p><img src="/static/IvLobogWcoYUrXxZljlc4MwlnBW.png"></p><p>出现新的错误</p><p>跟之前一样填进去。</p><p><img src="/static/FvuEbRdhEooNScxLt90cPu4bnMh.png"></p><p>发现并没有错误了，但是 cookie 并没有正常输出。</p><p>这是因为还有些未定义的东西没有进行添加。</p><p>一个一个来，首先是 head，这是一个属性所以在浏览器里查一查。</p><p><img src="/static/WuAbbAlxRoGI6DxHza6caG6Nntd.png"></p><p>是一段字符串，应该没用。可添可不添</p><p>下一个是</p><p><img src="/static/AaTibVhVqoH5xcxkRpWchLlqnCq.png"></p><p>添到 window 对象里。去浏览器查一下看看是方法还是属性。</p><p><img src="/static/G1nnbvRdSo4yilxQRQpcyzTVnPg.png"></p><p>看来是方法，那么跟 document 一样。</p><p>保存运行，出现新的错误：</p><p><img src="/static/Qi7sbdmrSo1DAcxCfIZcI2QyntC.png"></p><p>由输出可以看出这里的 addEventListener 是 document 对象的，那再补一下。</p><p><img src="/static/WuIlbAw07onwuFxCgB2cmR9InYg.png"></p><p>再次不报错，继续补未定义的东西。</p><p>下一个：</p><p><img src="/static/VTCAbDnrOoVPsBxQr3icutWHnpd.png"></p><p>去浏览器里搜搜。</p><p><img src="/static/E86dbVt0OoPemMxlNoZcmVLznOc.png"></p><p>navigator 是个对象，这里是它里面的 plugins 未定义，那么添进去。</p><p>接下来是</p><p><img src="/static/VT1KbKZKQoIkSxx4M0ocpy8cn9d.png"></p><p>同样的去浏览器里看看</p><p><img src="/static/AMyNb8EsPoQXLCxP7M8c5Yitnob.png"></p><p>本身就是未定义，那么就不用去管它了。</p><p>下一个</p><p><img src="/static/GPDKbQc9moZVNfxD1Zxcqg64nxd.png"></p><p><img src="/static/JQ8gbBpP7opCHMxOISOcSp5tnYc.png"></p><p>又是字符串，不用管。</p><p>但是如果不添加，那么好像不好输出下面一些未定义的东西，导致最后报错。这里还是放入吧，随便定义一个类型就行了，貌似没什么影响。</p><p>那么运行之后又出现了一个新的未定义的东西：</p><p><img src="/static/JuZVb62FzoILGkxAdvNc0K71nBe.png"></p><p>去浏览器里找，并·添上。</p><p>这样没有属性值为未定义的了，接下来保存运行，发现没有报错，但是依旧没有 cookie 输出。</p><p>这是因为 cookie 被封装在立即执行函数里，需要手动拉个接口。找到一开始定位到的 O 方法，在下面拉个接口，怎么拉都行。</p><p>最后运行输出 cookie：</p><p><img src="/static/LAc2bMelooCGOaxaO7mcDjOMnjd.png"></p><p>去 python 编辑器里输入 cookie</p><p>看看能不能用：</p><p>先让 v 为空：</p><p><img src="/static/RRl6bbVY8ogA3fx3KO9c2l8unrf.png"></p><p>运行结果如下：</p><p><img src="/static/GAcOb7Ojyoe2qTxB34KciAMOnbj.png"></p><p>什么都没有。</p><p>再添上刚刚获取的 cookie</p><p><img src="/static/FdfgbYeFZohhw7xaXT8c8zmtnGg.png"></p><p>发现完全不一样了。说明有效。</p><p>那么如何将 js 代码运用到 python 里呢，有两种方法，一种是用 execjs 库来运行 js 代码，另一种是用 subprocess 库来运行。第一种较难，容易报错。第二种代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 使用 subprocess 调用 Node.js</span><br><span class="line">try:</span><br><span class="line">    # 调用 Node.js 并捕获输出</span><br><span class="line">    result = subprocess.run(</span><br><span class="line">        [r&#x27;D:\爬虫工具\JavaScript逆向\node.js\node.exe&#x27;, r&#x27;D:\python_for_practise\JsReverse、\THSjsCookieReverse.js&#x27;],</span><br><span class="line">        capture_output=True,  # 捕获输出</span><br><span class="line">        text=True,  # 将输出作为字符串处理</span><br><span class="line">        encoding=&#x27;utf-8&#x27;</span><br><span class="line">    )</span><br><span class="line">    # 使用正则表达式提取 cookie</span><br><span class="line">    cookie_match = re.search(r&#x27;cookie is:(.*?)\n&#x27;, result.stdout)</span><br><span class="line">    if cookie_match:</span><br><span class="line">        cookie = cookie_match.group(1).strip()  # 去除多余空格</span><br><span class="line">        print(cookie)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;error&#x27;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(f&quot;Error: &#123;e&#125;&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 案例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>m3u8下载脚本</title>
      <link href="/2025/03/22/m3u8%E4%B8%8B%E8%BD%BD%E8%84%9A%E6%9C%AC-python/"/>
      <url>/2025/03/22/m3u8%E4%B8%8B%E8%BD%BD%E8%84%9A%E6%9C%AC-python/</url>
      
        <content type="html"><![CDATA[<hr><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 同步请求</span></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tqdm  <span class="comment"># 进度条(迭代)</span></span><br><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright  <span class="comment"># 同步</span></span><br><span class="line"><span class="keyword">from</span> playwright.async_api <span class="keyword">import</span> async_playwright  <span class="comment"># 异步</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp  <span class="comment"># 异步请求</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> keyboard</span><br><span class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, stop_after_attempt  <span class="comment"># 错误重试</span></span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0&#x27;</span>&#125;</span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">m3u8s = []</span><br><span class="line">keys = []</span><br><span class="line">limit = <span class="number">5</span>  <span class="comment"># 限制信号量</span></span><br><span class="line">semaphore = asyncio.Semaphore(limit)  <span class="comment"># 限制最高并发量为5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(<span class="params">stop=stop_after_attempt(<span class="params"><span class="number">5</span></span>)</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_page</span>(<span class="params">url</span>):  <span class="comment"># 解析URL，返回html</span></span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(url, headers=headers)</span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                response.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> response.text</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logging.error(<span class="string">&#x27;%s&#x27;</span>, response.status_code)</span><br><span class="line">        <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">            logging.error(<span class="string">&#x27;其他错误!&#x27;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.error(<span class="string">&#x27;url为空!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_response</span>(<span class="params">response</span>):  <span class="comment"># 事件监听回调</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;.m3u8&#x27;</span> <span class="keyword">in</span> response.url <span class="keyword">and</span> <span class="string">&#x27;mp4&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> response.url <span class="keyword">and</span> response.status == <span class="number">200</span>:</span><br><span class="line">        m3u8s.append(response.url)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;.key&#x27;</span> <span class="keyword">in</span> response.url <span class="keyword">and</span> response.status == <span class="number">200</span>:  <span class="comment"># 判断m3u8是否加密,一般是AES-128加密方式</span></span><br><span class="line">        keys.append(response.url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_ts</span>(<span class="params">json</span>):  <span class="comment"># 如果判断没有加密，那么直接提取出ts分流(只是一半)</span></span><br><span class="line">    mid_ts_urls = re.findall(<span class="string">r&#x27;#EXTINF:.*?,\n(.*?)\n&#x27;</span>, json, re.S)</span><br><span class="line">    <span class="keyword">if</span> mid_ts_urls <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> ts_urls <span class="keyword">in</span> mid_ts_urls:</span><br><span class="line">            ts_urls = ts_urls.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            full_ts_urls.append(ts_urls)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;http&#x27;</span> <span class="keyword">in</span> full_ts_urls[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;http&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;hls&#x27;</span> <span class="keyword">in</span> full_ts_urls[<span class="number">0</span>]:  <span class="comment"># 判断ts分流的url是不是统一的(有些带日期，有些不带)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;hls&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makefile</span>(<span class="params">name, base_url</span>):  <span class="comment"># 创建相应的动漫文件夹</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        name = name.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        path = <span class="string">f&#x27;<span class="subst">&#123;base_url&#125;</span>\\<span class="subst">&#123;name&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">            os.makedirs(path)</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">    <span class="keyword">except</span> PermissionError:</span><br><span class="line">        logging.error(PermissionError)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        logging.error(OSError)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_txt</span>(<span class="params">name, path</span>):  <span class="comment"># 检测并创建合并txt</span></span><br><span class="line">    name = name.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">        txt_path = <span class="string">f&#x27;<span class="subst">&#123;path&#125;</span>\\<span class="subst">&#123;name&#125;</span>.txt&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(txt_path):</span><br><span class="line">            logging.info(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>.txt已经存在&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> txt_path</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(txt_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(txt_path):</span><br><span class="line">                <span class="keyword">return</span> txt_path</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logging.error(<span class="string">&#x27;txt创建失败&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">num, content, path</span>):  <span class="comment"># 这里的path是动漫文件夹的路径, num可用循环</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;path&#125;</span>\\<span class="subst">&#123;num&#125;</span>.mp4&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(<span class="params">stop=stop_after_attempt(<span class="params"><span class="number">5</span></span>)</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">translate_bytes</span>(<span class="params">session, num</span>) -&gt; <span class="built_in">list</span>:  <span class="comment"># 参数为ts分流的url  异步函数有阻塞可协程加速</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(full_ts_urls[num], headers=headers) <span class="keyword">as</span> res:</span><br><span class="line">            <span class="keyword">if</span> res.status == <span class="number">200</span>:</span><br><span class="line">                content = <span class="keyword">await</span> res.read()</span><br><span class="line">                <span class="keyword">return</span> [content, num]  <span class="comment"># 设置阻塞</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                content = requests.get(full_ts_urls[<span class="number">0</span>], headers=headers).content  <span class="comment"># 实在没办法直接舍弃，改为第一个ts</span></span><br><span class="line">                <span class="keyword">return</span> [content, num]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_key</span>(<span class="params">key_url</span>):</span><br><span class="line">    res = requests.get(key_url)</span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> res.content</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(<span class="params">stop=stop_after_attempt(<span class="params"><span class="number">5</span></span>)</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decode</span>(<span class="params">encrypted_data, key, m3u8</span>):  <span class="comment"># 参数为ts分流视频的二进制，和秘钥，还有m3u8的文本</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;先判断是否是AES-128加密方式，KEY:METHOD=AES-128  如果是则进行解密。如果不是则捕捉异常，并输出给控制台。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        encryption = re.search(<span class="string">&#x27;KEY:.*?=(.*?),&#x27;</span>, m3u8, re.S).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(<span class="string">&#x27;KEY:.*?=(.*?),&#x27;</span>, m3u8, re.S) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> encryption <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> encryption == <span class="string">&#x27;AES-128&#x27;</span>:</span><br><span class="line">                <span class="string">&quot;&quot;&quot;AES-128解密&quot;&quot;&quot;</span></span><br><span class="line">                cipher = AES.new(key, AES.MODE_CBC, key)</span><br><span class="line">                data = cipher.decrypt(encrypted_data)</span><br><span class="line">                <span class="keyword">return</span> data  <span class="comment"># 这里返回的data是二进制，直接写入视频格式文件即可解密成功</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logging.info(<span class="string">&#x27;不是AES-128加密，请检查加密方式&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        logging.error(ValueError)</span><br><span class="line">        <span class="built_in">print</span>(encrypted_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_txt</span>(<span class="params">txt_path, path, num</span>):  <span class="comment"># 这里的path是文件夹路径, num与上面用法一样</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(txt_path):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(txt_path, <span class="string">&#x27;a+&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">f&quot;file &#x27;<span class="subst">&#123;path&#125;</span>\\<span class="subst">&#123;num&#125;</span>.mp4&#x27;&quot;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ffmpeg_combine</span>(<span class="params">video_path, txt_path, name, num</span>):  <span class="comment"># 这里是将txt里的视频路径依次合并，video_path需要用户输入</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;先查找txt_path是否存在，然后再依次合并, 并检查合并好的文件是否存在&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(txt_path):</span><br><span class="line">        name = name.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        order = <span class="string">f&#x27;ffmpeg -f concat -safe 0 -i <span class="subst">&#123;txt_path&#125;</span> -c copy <span class="subst">&#123;video_path&#125;</span>\\<span class="subst">&#123;name&#125;</span>第<span class="subst">&#123;num&#125;</span>集.mp4 -loglevel quiet&#x27;</span></span><br><span class="line">        subprocess.run(order)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(<span class="string">f&#x27;<span class="subst">&#123;video_path&#125;</span>\\<span class="subst">&#123;name&#125;</span>第<span class="subst">&#123;num&#125;</span>集.mp4&#x27;</span>):</span><br><span class="line">            logging.info(<span class="string">&#x27;下载成功啦!&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;下载失败了,原因是合并时出现了问题&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.error(<span class="string">f&#x27;<span class="subst">&#123;txt_path&#125;</span>不存在，请检查是否创建&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear</span>(<span class="params">file_path, txt_path</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(full_ts_urls)):</span><br><span class="line">            os.remove(<span class="string">f&#x27;<span class="subst">&#123;file_path&#125;</span>\\<span class="subst">&#123;i&#125;</span>.mp4&#x27;</span>)</span><br><span class="line">        os.remove(txt_path)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logging.error(<span class="string">&#x27;FileNotFoundError!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">cancel_requests</span>(<span class="params">route, request</span>):  <span class="comment"># 网络劫持，取消图片请求，就是js请求</span></span><br><span class="line">    <span class="keyword">await</span> route.abort()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(<span class="params">stop=stop_after_attempt(<span class="params"><span class="number">5</span></span>)</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">listen</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> async_playwright() <span class="keyword">as</span> p:  <span class="comment"># 事件监听</span></span><br><span class="line">        browser = <span class="keyword">await</span> p.firefox.launch(headless=<span class="literal">True</span>, args=[<span class="string">&#x27;--User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0&#x27;</span>], executable_path=<span class="string">r&#x27;D:\爬虫脚本\樱花动漫下载器v2.0\firefox\firefox.exe&#x27;</span>)</span><br><span class="line">        <span class="comment"># executable_path=r&#x27;firefox\firefox.exe</span></span><br><span class="line">        page = <span class="keyword">await</span> browser.new_page()</span><br><span class="line">        <span class="keyword">await</span> page.route(re.<span class="built_in">compile</span>(<span class="string">r&#x27;(\.png)|(\.jpg)|(\.ts)&#x27;</span>), cancel_requests)  <span class="comment"># 网络劫持,增加监听速度</span></span><br><span class="line">        page.on(<span class="string">&#x27;response&#x27;</span>, on_response)</span><br><span class="line">        <span class="keyword">await</span> page.goto(url)</span><br><span class="line">        <span class="comment"># page.wait_for_load_state(&#x27;networkidle&#x27;)</span></span><br><span class="line">        <span class="keyword">await</span> browser.close()</span><br><span class="line">        <span class="keyword">if</span> m3u8s:</span><br><span class="line">            <span class="built_in">print</span>(m3u8s[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    repair = []</span><br><span class="line">    repair_num = []</span><br><span class="line">    <span class="keyword">global</span> full_ts_urls</span><br><span class="line">    full_ts_urls = []</span><br><span class="line">    to_verify = <span class="built_in">input</span>(<span class="string">&#x27;你是否要程序自动从网页监听m3u8视频请求?(y or n):&#x27;</span>)</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&#x27;请输入名称:&#x27;</span>)</span><br><span class="line">    episode = <span class="built_in">input</span>(<span class="string">&#x27;请输入你下载的是第几集:&#x27;</span>)</span><br><span class="line">    base_path = <span class="built_in">input</span>(<span class="string">&#x27;请输入保存路径:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> to_verify == <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">        input_url = <span class="built_in">input</span>(<span class="string">&#x27;请输入网页url:&#x27;</span>)</span><br><span class="line">        logging.info(<span class="string">&#x27;正在监听网络请求中...(可能稍慢~请耐心等待, 如果失败请检查网络并重新启动)&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> listen(input_url)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        input_url = <span class="built_in">input</span>(<span class="string">&#x27;请输入m3u8网址:&#x27;</span>)</span><br><span class="line">        m3u8s.append(input_url)</span><br><span class="line">    <span class="keyword">if</span> m3u8s:</span><br><span class="line">        m3u8 = m3u8s[-<span class="number">1</span>]</span><br><span class="line">        m3u8_text = scrape_page(m3u8)</span><br><span class="line">        file_path = makefile(name, base_path)  <span class="comment"># 创建文件夹 .*?</span></span><br><span class="line">        txt_path = make_txt(name, file_path)  <span class="comment"># 创建txt文档</span></span><br><span class="line">        front_url = re.search(<span class="string">r&#x27;(.*/)([^/]+)\.m3u8$&#x27;</span>, m3u8).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(<span class="string">r&#x27;(.*/)([^/]+)\.m3u8$&#x27;</span>, m3u8) <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># 用贪婪匹配最后一个斜线前面的所有内容</span></span><br><span class="line">        <span class="comment"># other_part = re.search(r&#x27;(.*/)([^/]+)\.m3u8$&#x27;, m3u8).group(2).strip() if re.search(r&#x27;(.*/)([^/]+)\.m3u8$&#x27;, m3u8) else None  # 匹配最后一个斜线后面所有的内容</span></span><br><span class="line">        <span class="comment"># if front_url is not None and other_part is not None:</span></span><br><span class="line">        <span class="comment">#    front_url = front_url + other_part</span></span><br><span class="line">        true_false = read_ts(m3u8_text)</span><br><span class="line">        <span class="comment"># print(full_ts_urls)</span></span><br><span class="line">        <span class="keyword">if</span> true_false == <span class="string">&#x27;hls&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(full_ts_urls)):</span><br><span class="line">                full_ts_urls[i] = re.sub(<span class="string">&#x27;.*?/hls/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, full_ts_urls[i])</span><br><span class="line">                full_ts_urls[i] = front_url + full_ts_urls[i]</span><br><span class="line">        <span class="keyword">elif</span> true_false == <span class="string">&#x27;http&#x27;</span>:</span><br><span class="line">            <span class="keyword">pass</span>  <span class="comment"># 不做任何事情</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            full_ts_urls = [<span class="string">f&#x27;<span class="subst">&#123;front_url&#125;</span><span class="subst">&#123;url&#125;</span>&#x27;</span> <span class="keyword">for</span> url <span class="keyword">in</span> full_ts_urls]</span><br><span class="line">        <span class="keyword">if</span> keys:</span><br><span class="line">            key_url = keys[-<span class="number">1</span>]</span><br><span class="line">            key = translate_key(key_url)</span><br><span class="line">            <span class="comment"># print(key)</span></span><br><span class="line">            key_start = time.time()</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(headers=headers) <span class="keyword">as</span> session:  <span class="comment"># 协程</span></span><br><span class="line">                <span class="comment"># key = await translate_bytes(key_url, session)</span></span><br><span class="line">                <span class="comment"># print(full_ts_urls[0])</span></span><br><span class="line">                tasks = [asyncio.ensure_future(translate_bytes(session, num)) <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(full_ts_urls))]</span><br><span class="line">                <span class="comment">#  contents = await asyncio.gather(*tasks)</span></span><br><span class="line">                pbar = tqdm.tqdm(total=<span class="built_in">len</span>(full_ts_urls))</span><br><span class="line">                <span class="keyword">for</span> coroutine <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">                    content = <span class="keyword">await</span> coroutine</span><br><span class="line">                    <span class="comment"># print(content)</span></span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        data = aes_decode(content[<span class="number">0</span>], key, m3u8_text)  <span class="comment"># 解密(AES-128)</span></span><br><span class="line">                        write_data(content[<span class="number">1</span>], data, file_path)  <span class="comment"># num=content[1]</span></span><br><span class="line">                    <span class="keyword">except</span> TypeError:</span><br><span class="line">                        repair.append(content[<span class="number">0</span>])  <span class="comment"># 如果content列表没有元素怎么办</span></span><br><span class="line">                        repair_num.append(content[<span class="number">1</span>])</span><br><span class="line">                    pbar.update(<span class="number">1</span>)</span><br><span class="line">                pbar.close()</span><br><span class="line">                <span class="comment"># 补救</span></span><br><span class="line">                tried = []  <span class="comment"># 没办法，记录其num</span></span><br><span class="line">                <span class="keyword">if</span> repair_num:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repair_num)):</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            data = aes_decode(repair[i], key, m3u8_text)</span><br><span class="line">                            write_data(repair_num[i], data, file_path)</span><br><span class="line">                        <span class="keyword">except</span>:</span><br><span class="line">                            tried.append(repair_num[i])</span><br><span class="line">                is_tried = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(full_ts_urls)):</span><br><span class="line">                    <span class="keyword">if</span> tried:</span><br><span class="line">                        <span class="keyword">for</span> num <span class="keyword">in</span> tried:</span><br><span class="line">                            <span class="keyword">if</span> i == num:</span><br><span class="line">                                is_tried = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> is_tried:</span><br><span class="line">                        write_txt(txt_path, file_path, i)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        is_tried = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;正在清理内存中...&#x27;</span>)</span><br><span class="line">            ffmpeg_combine(file_path, txt_path, name, episode)</span><br><span class="line">            clear(file_path, txt_path)</span><br><span class="line">            key_end = time.time()</span><br><span class="line">            total_time = (key_end - key_start) / <span class="number">60</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;用时:&#x27;</span> + <span class="string">f&#x27;<span class="subst">&#123;total_time&#125;</span>min&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 没有加密</span></span><br><span class="line">            no_key_start = time.time()</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(headers=headers) <span class="keyword">as</span> session:  <span class="comment"># 协程</span></span><br><span class="line">                tasks = [asyncio.ensure_future(translate_bytes(session, num)) <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(full_ts_urls))]</span><br><span class="line">                <span class="comment">#  contents = await asyncio.gather(*tasks)</span></span><br><span class="line">                pbar = tqdm.tqdm(total=<span class="built_in">len</span>(full_ts_urls))</span><br><span class="line">                <span class="keyword">for</span> coroutine <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        content = <span class="keyword">await</span> coroutine</span><br><span class="line">                        write_data(content[<span class="number">1</span>], content[<span class="number">0</span>], file_path)  <span class="comment"># 写入解密后的数据</span></span><br><span class="line">                    <span class="keyword">except</span> TypeError:</span><br><span class="line">                        repair.append(content[<span class="number">0</span>])</span><br><span class="line">                        repair_num.append(content[<span class="number">1</span>])</span><br><span class="line">                    pbar.update(<span class="number">1</span>)</span><br><span class="line">                pbar.close()</span><br><span class="line">                <span class="comment"># 补救</span></span><br><span class="line">                tried = []  <span class="comment"># 没办法，记录其num</span></span><br><span class="line">                <span class="keyword">if</span> repair_num:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repair_num)):</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            write_data(repair_num[i], repair[i], file_path)</span><br><span class="line">                        <span class="keyword">except</span>:</span><br><span class="line">                            tried.append(repair_num[i])</span><br><span class="line">                is_tried = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(full_ts_urls)):</span><br><span class="line">                    <span class="keyword">if</span> tried:</span><br><span class="line">                        <span class="keyword">for</span> num <span class="keyword">in</span> tried:</span><br><span class="line">                            <span class="keyword">if</span> i == num:</span><br><span class="line">                                is_tried = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> is_tried:</span><br><span class="line">                        write_txt(txt_path, file_path, i)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        is_tried = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;正在清理内存中...&#x27;</span>)</span><br><span class="line">            ffmpeg_combine(file_path, txt_path, name, episode)</span><br><span class="line">            clear(file_path, txt_path)</span><br><span class="line">            no_key_end = time.time()</span><br><span class="line">            total_time = (no_key_end - no_key_start) / <span class="number">60</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;用时:&#x27;</span> + <span class="string">f&#x27;<span class="subst">&#123;total_time&#125;</span>min&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动漫已经失效&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;按ESC结束进程~o( =∩ω∩= )m&#x27;</span>)</span><br><span class="line">    keyboard.wait(<span class="string">&#x27;Esc&#x27;</span>)</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
